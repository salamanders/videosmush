package info.benjaminhill.videosmush.old

import info.benjaminhill.videosmush.AveragingImage
import info.benjaminhill.videosmush.BaseAveragingImage
import info.benjaminhill.videosmush.FrameWithPixelFormat
import org.bytedeco.ffmpeg.global.avutil.* // ktlint-disable no-wildcard-imports
import java.awt.image.BufferedImage
import java.nio.ByteBuffer
import java.nio.IntBuffer

class AveragingImageFrames
private constructor(
    override val width: Int,
    override val height: Int,
    private val sums: IntArray = IntArray(width * height * 3),
) : BaseAveragingImage(width, height) {

    override suspend operator fun plusAssign(other: FrameWithPixelFormat) {
        numAdded++
        require(numAdded * 255 < Int.MAX_VALUE) { "Possible overflow in DecodedImage after $numAdded adds." }
        when (other.pixelFormat.ffmpeg) {
            AV_PIX_FMT_BGR24, AV_PIX_FMT_BGRA -> {
                val data = other.frame.image[0] as ByteBuffer
                val stepSize = if (other.pixelFormat.ffmpeg == AV_PIX_FMT_BGR24) 3 else 4
                for (i in 0 until width * height) {
                    sums[i * 3 + 0] += (data[i * stepSize + 2].toInt() and 0xFF)
                    sums[i * 3 + 1] += (data[i * stepSize + 1].toInt() and 0xFF)
                    sums[i * 3 + 2] += (data[i * stepSize + 0].toInt() and 0xFF)
                }
            }

            AV_PIX_FMT_ARGB, AV_PIX_FMT_RGB32, AV_PIX_FMT_RGB24 -> {
                val data = other.frame.image[0] as IntBuffer
                for (i in 0 until width * height) {
                    sums[i * 3 + 0] += (data[i] shr 16 and 0xFF)
                    sums[i * 3 + 1] += (data[i] shr 8 and 0xFF)
                    sums[i * 3 + 2] += (data[i] shr 0 and 0xFF)
                }
            }

            else -> throw IllegalArgumentException("Bad pixel format: ${other.pixelFormat}")
        }
        other.frame.close()
    }

    override fun toBufferedImage(): BufferedImage {
        return BufferedImage(width, height, BufferedImage.TYPE_INT_RGB).apply {
            val pixels = IntArray(width * height) { i ->
                val r = (sums[i * 3 + 0].toFloat() / numAdded).toInt().coerceIn(0, 255)
                val g = (sums[i * 3 + 1].toFloat() / numAdded).toInt().coerceIn(0, 255)
                val b = (sums[i * 3 + 2].toFloat() / numAdded).toInt().coerceIn(0, 255)
                (r shl 16) or (g shl 8) or b
            }
            setRGB(0, 0, width, height, pixels, 0, width)
        }.also {
            sums.fill(0)
            numAdded = 0
        }
    }

    companion object {
        fun blankOf(width: Int, height: Int): AveragingImage =
            AveragingImageFrames(width = width, height = height)
    }
}